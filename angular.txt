Basic commands: 

ng new <name> => creates a new workspace and an initial project inside
ng serve -o  => it builds the application, starts development server, watches the source files + rebuild the application when we make changes
ng generate component <component_name>, e.g.: ng generate component rooms or using shortcut ng g c rooms 

When we make any changes in angular.json file, we have to restart the server, those changes are not watched. 

Module is a mechanism to group components, directives, pipes that are related. Module is created by using @NgModule decorator. Inside decorator there are a few properties, e.g.: 

imports => expects an array of modules
declarations => expects an array of components
bootstrap => here we define a root component of our module 

To check the doc about a method we can press F12 inside editor. 

ng add <dependency_name> vs npm install <dep_name> -> the difference is that ng add will also update config files, such as packages.json


=====

Displaying values using interpolation: 

Declaration in class:
myValue = "sometext";
.. then in the template:

<h1> {{ myValue }} </h1> 

Property binding:

Declaration in class:

someVar = "color: red";

then in template:

<p [style] = "someVar"> Text </p> 

So the "Text" message will be written using a red color. 

====

Directives:

*ngIf => it is a directive that conditionally display a template if condition is true. 

<div *ngIf="condition"> <p> Some template in here </p> </div>

*ngFor => it is used to traverse over an array and display the data inside the UI, it repeats the template for each element

<ul>
<li *ngFor="let element of ElementsList"> {{ element }} </li>
</ul>

^ For each element of ElementsList array, there will be a <li> rendered. 

<ng-template *ngFor="let element of myArr; let i = index"> {{ element }} {{ index }} </ng-template>

[ngSwitch] => works similarly as switch in e.g. java language

ngClass, ngStyle are used for styling purposes - to ngClass we can pass class names in an e.g. array etc., ngStyle is for styling ad hoc 

=== 

Pipes => they simply are a function that we apply on any expression/value in a template, to transform it into other value. 

someVar: number = 300;
<p> {{ someVar | currency: 'EUR' }} </p> <!-- it will display 300 â‚¬ -->

=== 

Communication between components: 

@Input() decorator marks a property as a receiver property. It can receive data from a parent component. Property binding is being used, so to use in child component a variable "myVar" that is declared in parent component we have to use:

In child component.ts 

@Input() myVar: string = "";

Then in html template, ordinary, by interpolation: {{ myVar }}

In parent component we have to use a property binding and bind it's "myVar" to child component seletor:

<child-component-name [myVar]="myVar"></child-component-name> 

==== 

Emitting data from  child into parent component: 

In the child component class:

@Output() eventEmitter = new EventEmitter<Type>(); 

Then, we have to bind, for example a button press in child component with emitting an event. 

In child template:

<button (click)="sendDataToParent()">Click me </button>

Inside child class:

varThatWeWantToEmitToParent: string = "some text";
sendDataToParent() : void {
  this.eventEmitter.emit(this.varThatWeWantToEmitToParent);
}

We also have to modify parent class and template:

inside a class: 

studentList: string[] = ["John K."];
  addStudent(studentData: string) {
    this.studentList.push(studentData);
  }
  
 Inside a parent template:
 
 <app-students (eventEmitter)="addStudent($event)"></app-students>
 
 So, we are listening for event emitter, if an event is raised we call addStudent function with parameter that is "varThatWeWantToEmitToParent" from the child component. 
 
 So, basically when a button in child component is being pressed, a value is passed from child component into parent component and that value is added into studentList by addStudent() method that takes one parameter, that parameter is stored under $event. 


=== 

@ViewChild - this decorator enables a parent component to access properties, methods etc from it's child component. 

For example, if we have a file called app-template.html and there is a element:

<div #myElement>Hello</div> 

If we want to obtain a reference to that element, we have to write (in .*ts component file) :
@ViewChild('myElement') myElement!: ElementRef;

If we want to obtain a reference to an child component, we have to write(assuming we are still in template.html file):

=== 

ngOnChanges - if we want to "listen" to parent variable changing, we can use(in child component): 

 @Input() watchedVariable: varType; 
 
 ngOnChanges(changes: SimpleChanges): void {
    if(changes['watchedVariable'] && !changes['watchedVariable'].isFirstChange()) {
        //instructions..
    }
  }

Above method executes when a change is noticed(but not first change). 

=== 

Ng-template:

<ng-template> 
  <p> some example text </p>
</ng-template>

This tag is always used along with directives such as ngIf, ngSwitch, ngFor. It does not render anything by itself, but it provides a possiblity to render something when given conditions are met. 

===
