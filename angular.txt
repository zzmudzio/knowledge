Basic commands: 

ng new <name> => creates a new workspace and an initial project inside
ng serve -o  => it builds the application, starts development server, watches the source files + rebuild the application when we make changes
ng generate component <component_name>, e.g.: ng generate component rooms or using shortcut ng g c rooms 
ng generate module <module_name>, e.g. generate module test or by using a shortcut ng g m test

When we make any changes in angular.json file, we have to restart the server, those changes are not watched. 

Module is a mechanism to group components, directives, pipes that are related. Module is created by using @NgModule decorator. Inside decorator there are a few properties, e.g.: 

imports => expects an array of modules
declarations => expects an array of components
bootstrap => here we define a root component of our module 

To check the doc about a method we can press F12 inside editor. 

ng add <dependency_name> vs npm install <dep_name> -> the difference is that ng add will also update config files, such as packages.json

!! There is a possibility to use a styling from parent component in child components. !! We do not have to set them separately. 

=====

Displaying values using interpolation: 

Declaration in class:
myValue = "sometext";
.. then in the template:

<h1> {{ myValue }} </h1> 

Property binding:

Declaration in class:

someVar = "color: red";

then in template:

<p [style] = "someVar"> Text </p> 

So the "Text" message will be written using a red color. 

====

Directives:

*ngIf => it is a directive that conditionally display a template if condition is true. 

<div *ngIf="condition"> <p> Some template in here </p> </div>

*ngFor => it is used to traverse over an array and display the data inside the UI, it repeats the template for each element

<ul>
<li *ngFor="let element of ElementsList"> {{ element }} </li>
</ul>

^ For each element of ElementsList array, there will be a <li> rendered. 

<ng-template *ngFor="let element of myArr; let i = index"> {{ element }} {{ index }} </ng-template>

[ngSwitch] => works similarly as switch in e.g. java language

ngClass, ngStyle are used for styling purposes - to ngClass we can pass class names in an e.g. array etc., ngStyle is for styling ad hoc 

=== 

Pipes => they simply are a function that we apply on any expression/value in a template, to transform it into other value. 

someVar: number = 300;
<p> {{ someVar | currency: 'EUR' }} </p> <!-- it will display 300 â‚¬ -->

=== 

Communication between components: 

@Input() decorator marks a property as a receiver property. It can receive data from a parent component. Property binding is being used, so to use in child component a variable "myVar" that is declared in parent component we have to use:

In child component.ts 

@Input() myVar: string = "";

Then in html template, ordinary, by interpolation: {{ myVar }}

In parent component we have to use a property binding and bind it's "myVar" to child component seletor:

<child-component-name [myVar]="myVar"></child-component-name> 

==== 

Emitting data from  child into parent component: 

In the child component class:

@Output() eventEmitter = new EventEmitter<Type>(); 

Then, we have to bind, for example a button press in child component with emitting an event. 

In child template:

<button (click)="sendDataToParent()">Click me </button>

Inside child class:

varThatWeWantToEmitToParent: string = "some text";
sendDataToParent() : void {
  this.eventEmitter.emit(this.varThatWeWantToEmitToParent);
}

We also have to modify parent class and template:

inside a class: 

studentList: string[] = ["John K."];
  addStudent(studentData: string) {
    this.studentList.push(studentData);
  }
  
 Inside a parent template:
 
 <app-students (eventEmitter)="addStudent($event)"></app-students>
 
 So, we are listening for event emitter, if an event is raised we call addStudent function with parameter that is "varThatWeWantToEmitToParent" from the child component. 
 
 So, basically when a button in child component is being pressed, a value is passed from child component into parent component and that value is added into studentList by addStudent() method that takes one parameter, that parameter is stored under $event. 


=== 

@ViewChild - this decorator enables a parent component to access properties, methods etc from it's child component. 

For example, if we have a file called app-template.html and there is a element:

<div #myElement>Hello</div> 

If we want to obtain a reference to that element, we have to write (in .*ts component file) :
@ViewChild('myElement') myElement!: ElementRef;

If we want to obtain a reference to an child component, we have to write(assuming we are still in template.html file):

=== 

ngOnChanges - if we want to "listen" to parent variable changing, we can use(in child component): 

 @Input() watchedVariable: varType; 
 
 ngOnChanges(changes: SimpleChanges): void {
    if(changes['watchedVariable'] && !changes['watchedVariable'].isFirstChange()) {
        //instructions..
    }
  }

Above method executes when a change is noticed(but not first change). 

=== 

Ng-template:

<ng-template> 
  <p> some example text </p>
</ng-template>

This tag is always used along with directives such as ngIf, ngSwitch, ngFor. It does not render anything by itself, but it provides a possiblity to render something when given conditions are met. 

===

<ng-content> Helps us to pass html content from parent component inside a child component. It can be treated as an argument to component. 

If we have a couple <ng-content> tags inside a view, without using "select", only the last one will be rendered. 
====

Two way databinding: 

If we want to exchange data between template and a controller we have to use two way data binding. 

We have to import FormsModule and then, in a template, for example:

<input [(ngModule)="myVar"]> 

In a controller: 

myVar: string = ""; 

So, when myVar will change in a template, it will also be updated in a contoller, the same in the opposite way. 

=== 

Template reference variables: they help us to use a data from one part of the template in an other part. 
Let's say we have an input: 
<input type="text" #myVar (input)="someAction()> 
If we want to use a value of that input in other place inside our template, we just have to use: {{ myVar.value }} 
There has to be an event added(in this case `input`) for angular to run change check if we want to "live" display of the value that is being inputed into our field. 
It works the same in case we have some child components inside our component, we can gain an access into their fields, methods etc. 


==== 

Custom directives:

If we use a directive on e.g. <p> element, this element will be passed into a constructor method of directive class but the logic should be written outside of the constructor, preferably in ngOnInit method. 

To generate a directive:
ng g d directiveName

Then inside a directive we have to specify what will be passed into it's constructor. As mentioned above, the logic should be implemented outside the constructor, e.g. in ngOnInit method. 

constructor(private element: ElementRef) 
  {}

ngOnInit()
  {
    this.element.... // and the rest of the directive logic
  }

To use a directive inside an html tag as an attribute we have to use e.g. <p myNewDirective> some text </p> 
